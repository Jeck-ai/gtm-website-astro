---
---

<div id="text-container" class="relative w-full h-[424px] overflow-hidden rounded-lg">
  <!-- Fallback static text visible initially -->
  <h2 id="fallback-text" class="absolute text-5xl font-bold text-center w-full top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-indigo-600">
    GTM
  </h2>
  
  <!-- Canvas for the animation -->
  <canvas id="animation-canvas" class="w-full h-full hidden"></canvas>
  
  <!-- Debug output -->
  <div id="debug-output" class="absolute bottom-2 left-2 text-xs text-white opacity-50"></div>
</div>

<script is:inline>
  // Simplified version for debugging
  document.addEventListener('DOMContentLoaded', function() {
    const debugOutput = document.getElementById('debug-output');
    const canvas = document.getElementById('animation-canvas');
    const fallbackText = document.getElementById('fallback-text');
    
    function log(message) {
      if (debugOutput) {
        debugOutput.textContent += message + " | ";
      }
      console.log(message);
    }
    
    log("Script started");
    
    if (!canvas) {
      log("Canvas not found");
      return;
    }
    
    try {
      const ctx = canvas.getContext('2d');
      if (!ctx) {
        log("Couldn't get canvas context");
        return;
      }
      
      log("Got canvas context");
      
      // Set canvas dimensions
      const container = canvas.parentElement;
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      canvas.style.width = container.clientWidth + 'px';
      canvas.style.height = container.clientHeight + 'px';
      
      log(`Canvas size: ${canvas.width}x${canvas.height}`);
      
      // Show canvas, hide fallback
      canvas.classList.remove('hidden');
      if (fallbackText) fallbackText.classList.add('hidden');
      
      // Draw simple colorful GTM text to confirm rendering works
      ctx.fillStyle = '#000104'; // Dark background
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw text
      const fontSize = Math.min(canvas.width / 6, 80);
      ctx.font = `bold ${fontSize}px Arial, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      // G in blue
      ctx.fillStyle = '#4F46E5';
      ctx.fillText('G', canvas.width/2 - fontSize, canvas.height/2);
      
      // T in green
      ctx.fillStyle = '#10B981';
      ctx.fillText('T', canvas.width/2, canvas.height/2);
      
      // M in purple
      ctx.fillStyle = '#8B5CF6';
      ctx.fillText('M', canvas.width/2 + fontSize, canvas.height/2);
      
      log("Basic rendering complete");
      
      // Set up animation cycle
      function animate() {
        // Simple animation to confirm it's working - rotate hues
        const time = Date.now() / 1000;
        
        ctx.fillStyle = '#000104';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // G with animated hue
        ctx.fillStyle = `hsl(${(time * 30) % 360}, 80%, 60%)`;
        ctx.fillText('G', canvas.width/2 - fontSize, canvas.height/2);
        
        // T with animated hue
        ctx.fillStyle = `hsl(${(time * 30 + 120) % 360}, 80%, 60%)`;
        ctx.fillText('T', canvas.width/2, canvas.height/2);
        
        // M with animated hue
        ctx.fillStyle = `hsl(${(time * 30 + 240) % 360}, 80%, 60%)`;
        ctx.fillText('M', canvas.width/2 + fontSize, canvas.height/2);
        
        requestAnimationFrame(animate);
      }
      
      // Start animation
      log("Starting animation");
      animate();
    } catch (error) {
      log(`Error: ${error.message}`);
    }
  });
</script>
