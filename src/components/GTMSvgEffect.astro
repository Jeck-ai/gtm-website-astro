---
---

<div class="relative w-full h-[424px] overflow-hidden rounded-lg">
  <svg id="gtm-svg" class="w-full h-full" viewBox="0 0 600 400" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <!-- Define radial gradient for background -->
      <radialGradient id="bg-gradient" cx="50%" cy="50%" r="70%" fx="50%" fy="50%">
        <stop offset="0%" stop-color="#111827" />
        <stop offset="100%" stop-color="#0c131f" />
      </radialGradient>
      
      <!-- Define filter for glow effect -->
      <filter id="glow" x="-20%" y="-20%" width="140%" height="140%">
        <feGaussianBlur stdDeviation="5" result="blur" />
        <feMerge>
          <feMergeNode in="blur" />
          <feMergeNode in="SourceGraphic" />
        </feMerge>
      </filter>
    </defs>
    
    <!-- Background -->
    <rect width="100%" height="100%" fill="url(#bg-gradient)" />
    
    <!-- Group for G letter particles -->
    <g id="g-letter" class="letter-group">
      <!-- Particles will be added here via JavaScript -->
    </g>
    
    <!-- Group for T letter particles -->
    <g id="t-letter" class="letter-group">
      <!-- Particles will be added here via JavaScript -->
    </g>
    
    <!-- Group for M letter particles -->
    <g id="m-letter" class="letter-group">
      <!-- Particles will be added here via JavaScript -->
    </g>
  </svg>
</div>

<style>
  .letter-group circle {
    transition: cx 1.5s, cy 1.5s, r 0.5s, fill 1s;
  }
</style>

<script is:inline>
  // SVG-based GTM animation
  document.addEventListener('DOMContentLoaded', function() {
    console.log('SVG animation init');
    // Get SVG elements
    const svg = document.getElementById('gtm-svg');
    const gGroup = document.getElementById('g-letter');
    const tGroup = document.getElementById('t-letter');
    const mGroup = document.getElementById('m-letter');
    
    if (!svg || !gGroup || !tGroup || !mGroup) {
      console.error('SVG elements not found');
      return;
    }
    
    // Configuration
    const letterSpacing = 150;
    const colors = {
      g: { main: '#4F46E5', accent: '#818CF8' }, // Indigo
      t: { main: '#3B82F6', accent: '#60A5FA' }, // Blue
      m: { main: '#10B981', accent: '#34D399' }  // Emerald
    };
    
    // Particle definitions for each letter
    const letterData = {
      g: {
        center: { x: 150, y: 200 },
        particleCount: 40,
        particlePositions: []
      },
      t: {
        center: { x: 300, y: 200 },
        particleCount: 36,
        particlePositions: []
      },
      m: {
        center: { x: 450, y: 200 },
        particleCount: 50,
        particlePositions: []
      }
    };
    
    // Generate particle positions for letter G
    function generateGParticles() {
      const cx = letterData.g.center.x;
      const cy = letterData.g.center.y;
      const radius = 60;
      
      for (let i = 0; i < letterData.g.particleCount; i++) {
        // Calculate positions around a G shape
        let angle, r, x, y;
        
        if (i < letterData.g.particleCount * 0.75) {
          // Create 3/4 of a circle for the main part of G
          angle = (i / (letterData.g.particleCount * 0.75)) * Math.PI * 1.5 + Math.PI * 0.25;
          r = radius * (0.9 + Math.random() * 0.2);
          x = cx + r * Math.cos(angle);
          y = cy + r * Math.sin(angle);
        } else {
          // Create horizontal line for the "serif" of G
          const progress = (i - letterData.g.particleCount * 0.75) / (letterData.g.particleCount * 0.25);
          x = cx + radius * 0.2 + progress * radius * 0.6;
          y = cy + Math.random() * 10 - 5;
        }
        
        letterData.g.particlePositions.push({ x, y });
      }
    }
    
    // Generate particle positions for letter T
    function generateTParticles() {
      const cx = letterData.t.center.x;
      const cy = letterData.t.center.y;
      const width = 70;
      const height = 80;
      
      for (let i = 0; i < letterData.t.particleCount; i++) {
        let x, y;
        
        if (i < letterData.t.particleCount * 0.6) {
          // Horizontal bar of the T
          x = cx + (Math.random() * width - width/2);
          y = cy - height/2 + (Math.random() * 14 - 7);
        } else {
          // Vertical stem of the T
          x = cx + (Math.random() * 14 - 7);
          y = cy - height/2 + (Math.random() * height);
        }
        
        letterData.t.particlePositions.push({ x, y });
      }
    }
    
    // Generate particle positions for letter M
    function generateMParticles() {
      const cx = letterData.m.center.x;
      const cy = letterData.m.center.y;
      const width = 80;
      const height = 80;
      
      for (let i = 0; i < letterData.m.particleCount; i++) {
        let x, y;
        
        if (i < letterData.m.particleCount * 0.2) {
          // Left vertical stem
          x = cx - width/2 + (Math.random() * 14 - 7);
          y = cy - height/2 + (Math.random() * height);
        } else if (i < letterData.m.particleCount * 0.4) {
          // First diagonal
          const progress = (i - letterData.m.particleCount * 0.2) / (letterData.m.particleCount * 0.2);
          x = cx - width/2 + progress * width/2;
          y = cy - height/2 + height * progress;
        } else if (i < letterData.m.particleCount * 0.6) {
          // Second diagonal
          const progress = (i - letterData.m.particleCount * 0.4) / (letterData.m.particleCount * 0.2);
          x = cx + progress * width/2;
          y = cy - height * progress;
        } else {
          // Right vertical stem
          x = cx + width/2 + (Math.random() * 14 - 7);
          y = cy - height/2 + (Math.random() * height);
        }
        
        letterData.m.particlePositions.push({ x, y });
      }
    }
    
    // Create SVG particle elements
    function createParticles() {
      // Generate positions
      generateGParticles();
      generateTParticles();
      generateMParticles();
      
      // Create actual SVG elements
      function createParticlesForLetter(letter, group, colorSet) {
        const positions = letterData[letter].particlePositions;
        
        for (let i = 0; i < positions.length; i++) {
          const pos = positions[i];
          const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          
          // Initial random positions
          const randomX = Math.random() * 600;
          const randomY = Math.random() * 400;
          
          // Set attributes
          circle.setAttribute('cx', randomX);
          circle.setAttribute('cy', randomY);
          circle.setAttribute('r', 3 + Math.random() * 4);
          
          // Determine color (mix of main and accent)
          const useAccent = Math.random() > 0.7;
          const color = useAccent ? colorSet.accent : colorSet.main;
          circle.setAttribute('fill', color);
          
          // Add particle data
          circle.dataset.targetX = pos.x;
          circle.dataset.targetY = pos.y;
          circle.dataset.originalX = pos.x;
          circle.dataset.originalY = pos.y;
          
          // Add opacity for glow effect
          circle.setAttribute('opacity', 0.7 + Math.random() * 0.3);
          
          // Apply filter for glow
          if (useAccent) {
            circle.setAttribute('filter', 'url(#glow)');
          }
          
          // Add to group
          group.appendChild(circle);
        }
      }
      
      createParticlesForLetter('g', gGroup, colors.g);
      createParticlesForLetter('t', tGroup, colors.t);
      createParticlesForLetter('m', mGroup, colors.m);
    }
    
    // Animate particles to form letters
    function formLetters() {
      const letters = ['g', 't', 'm'];
      const groups = [gGroup, tGroup, mGroup];
      
      letters.forEach((letter, index) => {
        const particles = groups[index].querySelectorAll('circle');
        
        particles.forEach((circle, i) => {
          // Add slight delay for each particle
          setTimeout(() => {
            circle.setAttribute('cx', circle.dataset.targetX);
            circle.setAttribute('cy', circle.dataset.targetY);
          }, i * 20 + Math.random() * 500);
        });
      });
    }
    
    // Explode letters into random positions
    function explodeLetters() {
      const groups = [gGroup, tGroup, mGroup];
      
      groups.forEach(group => {
        const particles = group.querySelectorAll('circle');
        
        particles.forEach(circle => {
          // Generate new random position
          const randomX = Math.random() * 600;
          const randomY = Math.random() * 400;
          
          // Move particle
          circle.setAttribute('cx', randomX);
          circle.setAttribute('cy', randomY);
          
          // Random size change
          circle.setAttribute('r', 2 + Math.random() * 5);
          
          // Random color shift
          const hue = Math.floor(Math.random() * 60);
          const sat = 70 + Math.random() * 30;
          const light = 50 + Math.random() * 20;
          circle.setAttribute('fill', `hsl(${hue + 210}, ${sat}%, ${light}%)`);
        });
      });
    }
    
    // Animation cycle
    function startAnimationCycle() {
      // Initial formation
      setTimeout(formLetters, 1000);
      
      // Set up the cycle
      let isFormed = true;
      
      setInterval(() => {
        if (isFormed) {
          explodeLetters();
        } else {
          formLetters();
        }
        isFormed = !isFormed;
      }, 5000);
    }
    
    // Initialize animation
    createParticles();
    startAnimationCycle();
  });
</script>
