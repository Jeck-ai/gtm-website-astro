---
interface Props {
  text?: string;
  textColor?: string;
  height?: number;
}

const {
  text = "GTM Ventures",
  textColor = "#ffffff",
  height = 300
} = Astro.props;
---

<div id="text-effect-container" class="w-full h-[424px] rounded-lg overflow-hidden relative">
  <!-- Loading indicator -->
  <div id="loading-text" class="absolute inset-0 flex items-center justify-center text-white text-lg">
    Loading 3D effect...
  </div>
</div>

<script define:vars={{ text, textColor, height }}>
  import * as THREE from 'three';
  
  // Check for WebGL support
  function isWebGLAvailable() {
    try {
      const canvas = document.createElement('canvas');
      return !!(window.WebGLRenderingContext && 
        (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
    } catch (e) {
      console.error('WebGL not supported:', e);
      return false;
    }
  }

  async function loadThreeAddons() {
    try {
      console.log('Attempting to load Three.js addons dynamically...');
      // Dynamic imports for Three.js addons
      const fontLoaderModule = await import('three/addons/loaders/FontLoader.js');
      const textGeometryModule = await import('three/addons/geometries/TextGeometry.js');
      
      console.log('Successfully loaded modules:', { 
        fontLoader: !!fontLoaderModule.FontLoader, 
        textGeometry: !!textGeometryModule.TextGeometry 
      });
      
      return {
        FontLoader: fontLoaderModule.FontLoader,
        TextGeometry: textGeometryModule.TextGeometry
      };
    } catch (error) {
      console.error('Error loading Three.js addons:', error);
      
      // Try direct import from CDN as a fallback
      try {
        console.log('Attempting fallback to direct script loading...');
        
        // Load FontLoader and TextGeometry from CDN
        await new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = 'https://cdn.jsdelivr.net/npm/three@0.175.0/examples/jsm/loaders/FontLoader.js';
          script.onload = resolve;
          script.onerror = reject;
          document.head.appendChild(script);
        });
        
        await new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = 'https://cdn.jsdelivr.net/npm/three@0.175.0/examples/jsm/geometries/TextGeometry.js';
          script.onload = resolve;
          script.onerror = reject;
          document.head.appendChild(script);
        });
        
        console.log('Fallback script loading complete');
        
        // Check if globals were created
        if (window.THREE && window.THREE.FontLoader && window.THREE.TextGeometry) {
          return {
            FontLoader: window.THREE.FontLoader,
            TextGeometry: window.THREE.TextGeometry
          };
        }
      } catch (cdnError) {
        console.error('CDN fallback also failed:', cdnError);
      }
      
      // Try to use global THREE as last resort
      console.log('Checking for global THREE properties...');
      console.log('Available THREE properties:', Object.keys(THREE));
      
      return {
        FontLoader: THREE.FontLoader || function() { 
          console.error('FontLoader unavailable');
          throw new Error('FontLoader not available');
        },
        TextGeometry: THREE.TextGeometry || function() { 
          console.error('TextGeometry unavailable');
          throw new Error('TextGeometry not available');
        }
      };
    }
  }

  async function init3DText() {
    console.log('Initializing 3D Text Effect...');
    
    if (!isWebGLAvailable()) {
      console.error('WebGL is not supported by your browser');
      hideLoading();
      return;
    }
    
    const container = document.getElementById('text-effect-container');
    if (!container) {
      console.error('Text effect container not found');
      hideLoading();
      return;
    }
    
    try {
      // Dimensions and setup
      const width = container.clientWidth;
      const containerHeight = height || container.clientHeight;
      
      // Get Three.js addons
      const { FontLoader, TextGeometry } = await loadThreeAddons();
      
      // Scene setup
      const scene = new THREE.Scene();
      
      // Camera
      const camera = new THREE.PerspectiveCamera(75, width / containerHeight, 0.1, 1000);
      camera.position.z = 200;
      
      // Renderer
      const renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        alpha: true
      });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(width, containerHeight);
      renderer.setClearColor(0x000000, 0); // Transparent background
      
      // Clear any previous instances
      while (container.firstChild) {
        container.removeChild(container.firstChild);
      }
      
      container.appendChild(renderer.domElement);
      
      // Lights
      const ambientLight = new THREE.AmbientLight(0x404040, 2);
      scene.add(ambientLight);
      
      const pointLight = new THREE.PointLight(0xffffff, 1);
      pointLight.position.set(100, 100, 100);
      scene.add(pointLight);
      
      const pointLight2 = new THREE.PointLight(0x0088ff, 1);
      pointLight2.position.set(-100, -100, 100);
      scene.add(pointLight2);
      
      // Mouse movement tracking
      let mouseX = 0;
      let mouseY = 0;
      
      document.addEventListener('mousemove', (event) => {
        mouseX = (event.clientX - window.innerWidth / 2);
        mouseY = (event.clientY - window.innerHeight / 2);
      });
      
      // For mobile devices
      document.addEventListener('touchmove', (event) => {
        if (event.touches.length > 0) {
          mouseX = (event.touches[0].clientX - window.innerWidth / 2);
          mouseY = (event.touches[0].clientY - window.innerHeight / 2);
        }
      });
      
      // Handle window resize
      function handleResize() {
        const newWidth = container.clientWidth;
        camera.aspect = newWidth / containerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(newWidth, containerHeight);
      }
      
      window.addEventListener('resize', handleResize);
      
      // Load font
      const fontLoader = new FontLoader();
      
      // Use a font from Three.js examples
      fontLoader.load('https://threejs.org/examples/fonts/helvetiker_bold.typeface.json', function(font) {
        // Create text geometry
        const textString = text;
        const textGeometry = new TextGeometry(textString, {
          font: font,
          size: text.length > 15 ? 20 : 30,
          height: 5,
          curveSegments: 12,
          bevelEnabled: true,
          bevelThickness: 1,
          bevelSize: 0.5,
          bevelOffset: 0,
          bevelSegments: 5
        });
        
        // Center text
        textGeometry.computeBoundingBox();
        const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
        textGeometry.translate(-textWidth / 2, 0, 0);
        
        // Create material with glowing effect
        const textMaterial = new THREE.MeshStandardMaterial({
          color: textColor,
          metalness: 0.5,
          roughness: 0.2,
          emissive: new THREE.Color(textColor).multiplyScalar(0.2),
        });
        
        // Create particle system for text
        const particleCount = 5000;
        const particlesGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);
        
        // Generate particles around text geometry
        for (let i = 0; i < particleCount; i++) {
          const i3 = i * 3;
          particlePositions[i3] = (Math.random() - 0.5) * textWidth * 2;
          particlePositions[i3 + 1] = (Math.random() - 0.5) * 40;
          particlePositions[i3 + 2] = (Math.random() - 0.5) * 40;
        }
        
        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        
        // Particle material
        const particleMaterial = new THREE.PointsMaterial({
          color: 0x0088ff,
          size: 0.8,
          transparent: true,
          opacity: 0.6,
          blending: THREE.AdditiveBlending
        });
        
        const particles = new THREE.Points(particlesGeometry, particleMaterial);
        scene.add(particles);
        
        // Create text mesh
        const textMesh = new THREE.Mesh(textGeometry, textMaterial);
        scene.add(textMesh);
        
        // Remove loading indicator
        hideLoading();
        
        // Animation
        let frame = 0;
        function animate() {
          requestAnimationFrame(animate);
          
          frame += 0.01;
          
          // Rotate text slowly
          textMesh.rotation.y = Math.sin(frame * 0.5) * 0.1;
          textMesh.rotation.x = Math.sin(frame * 0.3) * 0.05;
          
          // Animate particles
          const positions = particlesGeometry.attributes.position.array;
          for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            positions[i3 + 1] += Math.sin((i + frame) * 0.1) * 0.05;
            positions[i3] += Math.cos((i + frame) * 0.1) * 0.05;
          }
          particlesGeometry.attributes.position.needsUpdate = true;
          
          // Subtle movement of the entire scene based on mouse position
          scene.rotation.y = mouseX * 0.0005;
          scene.rotation.x = mouseY * 0.0005;
          
          renderer.render(scene, camera);
        }
        
        animate();
      });
      
    } catch (err) {
      console.error('Error initializing 3D text effect:', err);
      hideLoading();
      
      // Show fallback text if 3D effect fails
      const container = document.getElementById('text-effect-container');
      if (container) {
        const fallback = document.createElement('div');
        fallback.className = 'fallback-text';
        fallback.textContent = text;
        container.appendChild(fallback);
      }
    }
  }
  
  function hideLoading() {
    const loadingElement = document.getElementById('loading-text');
    if (loadingElement) {
      loadingElement.style.display = 'none';
    }
  }

  // Initialize on load
  function loadTextEffect() {
    console.log('Loading 3D text effect...');
    // Wait a bit for the DOM to be fully rendered
    setTimeout(() => {
      init3DText().catch(err => {
        console.error('Failed to initialize 3D text:', err);
        hideLoading();
        
        // Show fallback text if 3D effect fails
        const container = document.getElementById('text-effect-container');
        if (container) {
          const fallback = document.createElement('div');
          fallback.className = 'fallback-text';
          fallback.textContent = text;
          container.appendChild(fallback);
        }
      });
    }, 300);
  }

  // Use multiple event listeners to ensure the effect loads
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', loadTextEffect);
  } else {
    loadTextEffect();
  }

  // Also handle window load event as a fallback
  window.addEventListener('load', () => {
    console.log('Window loaded, ensuring 3D text is initialized');
    if (!document.querySelector('#text-effect-container canvas')) {
      loadTextEffect();
    }
  });
</script>

<style>
  #text-effect-container {
    position: relative;
    z-index: 1;
  }
  
  #loading-text {
    background-color: rgba(0, 0, 0, 0.5);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 0.5rem;
  }
  
  .fallback-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 2.5rem;
    font-weight: bold;
    color: white;
    text-align: center;
    text-shadow: 0 0 10px rgba(0, 136, 255, 0.8);
  }
</style>
